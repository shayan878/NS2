#ifndef lint
static const char rcsid[] =
    "@(#) $Header: /cvsroot/nsnam/ns-2/tcp/tcp-bbr.cc,v 1.0 2024/12/13 18:05:30 student Exp $ (LBL)";
#endif

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <cmath> 
#include "ip.h"
#include "tcp.h"
#include "flags.h"
#include <algorithm>


class BBRRenoTcpAgent : public RenoTcpAgent {
public:
    BBRRenoTcpAgent();
    void recv(Packet *pkt, Handler*);
    void timeout(int tno);

protected:
    double bottleneck_bandwidth_;
    double min_rtt_;
    double pacing_rate_;
    double send_rate_;
    double last_ack_bytes_;
    double last_time_;
    int state_;

    enum BBRState { STARTUP, DRAIN, PROBE_BW, PROBE_RTT };

    void update_bandwidth(double ack_bytes, double current_time);
    void update_rtt(double current_rtt);
    void adjust_pacing_rate();
    void adjust_congestion_window();
};

BBRRenoTcpAgent::BBRRenoTcpAgent()
    : RenoTcpAgent(),
      bottleneck_bandwidth_(0),
      min_rtt_(1e9),
      pacing_rate_(0),
      send_rate_(1.0), 
      last_ack_bytes_(0),
      last_time_(0),
      state_(STARTUP) {}

void BBRRenoTcpAgent::recv(Packet *pkt, Handler *h) {
    hdr_tcp *tcph = hdr_tcp::access(pkt);

    if (tcph->ts() < lastreset_) {
        Packet::free(pkt);
        return;
    }

    double ack_bytes = tcph->seqno();
    double current_time = Scheduler::instance().clock();
    
    update_bandwidth(ack_bytes, current_time);
    double current_rtt = std::max(current_time - tcph->ts(), 0.001); 
    update_rtt(current_rtt);

    adjust_pacing_rate();
    adjust_congestion_window();

    RenoTcpAgent::recv(pkt, h);
}

void BBRRenoTcpAgent::update_bandwidth(double ack_bytes, double current_time) {
    if (last_time_ > 0) {
        double interval = current_time - last_time_;
        if (interval > 0) {
            double current_bandwidth = (ack_bytes - last_ack_bytes_) / interval;
            bottleneck_bandwidth_ = std::max(bottleneck_bandwidth_, current_bandwidth);
        }
    }
    last_ack_bytes_ = ack_bytes;
    last_time_ = current_time;
}

void BBRRenoTcpAgent::update_rtt(double current_rtt) {
    if (current_rtt > 0) {
        min_rtt_ = std::min(min_rtt_, current_rtt);
    }
}

void BBRRenoTcpAgent::adjust_pacing_rate() {
    switch (state_) {
    case STARTUP:
        pacing_rate_ = bottleneck_bandwidth_ * 2; 
        if (bottleneck_bandwidth_ > 0.9 * bottleneck_bandwidth_) {
            state_ = DRAIN;
        }
        break;

    case DRAIN:
        pacing_rate_ = bottleneck_bandwidth_ * min_rtt_ / std::max(min_rtt_, 0.001); 
        if (pacing_rate_ * min_rtt_ <= cwnd_) {
            state_ = PROBE_BW;
        }
        break;

    case PROBE_BW:
        pacing_rate_ = bottleneck_bandwidth_ * (1 + 0.05 * std::sin(Scheduler::instance().clock())); 
        if (Scheduler::instance().clock() - last_time_ > 5 * min_rtt_) { 
            state_ = PROBE_RTT;
        }
        break;

    case PROBE_RTT:
        pacing_rate_ = bottleneck_bandwidth_ * 0.75; 
        if (Scheduler::instance().clock() - last_time_ > min_rtt_) {
            state_ = PROBE_BW;
        }
        break;
    }

    send_rate_ = pacing_rate_; 
}

void BBRRenoTcpAgent::adjust_congestion_window() {
    cwnd_ = std::max(1.0, pacing_rate_ * min_rtt_); 
}

void BBRRenoTcpAgent::timeout(int tno) {
    if (tno == TCP_TIMER_RTX) {
        state_ = STARTUP; 
        bottleneck_bandwidth_ *= 0.5; 
        min_rtt_ = min_rtt_; 
        pacing_rate_ = 0;
        send_rate_ = 1.0;
        last_ack_bytes_ = 0;
        last_time_ = 0;
    }
    RenoTcpAgent::timeout(tno);
}

static class BBRRenoTcpClass : public TclClass {
public:
    BBRRenoTcpClass() : TclClass("Agent/TCP/Reno/BBR") {
    }
    TclObject* create(int, const char*const*) {
        return new BBRRenoTcpAgent(); 
    }
} class_bbr_reno;
